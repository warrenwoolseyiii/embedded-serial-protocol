/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package serial.protocol

class Library {

    // Public constants for byte positions and values
    companion object {
        const val HEADER_POS_0 = 0
        const val HEADER_POS_1 = 1
        const val HEADER_POS_2 = 2
        const val SRC_ADDRESS_POS = 3
        const val TGT_ADDRESS_POS = 4
        const val MSG_TYPE_POS = 5
        const val PAYLOAD_LENGTH_MSB_POS = 6
        const val PAYLOAD_LENGTH_LSB_POS = 7
        const val PAYLOAD_POS = 8
        const val HEADER_0 = 0xAA.toByte()
        const val HEADER_1 = 0x55.toByte()
        const val HEADER_2 = 0xFF.toByte()
        const val MAX_PAYLOAD_LENGTH = 65535
        const val NUM_OVERHEAD_BYTES = 10
        const val PROTOCOL_VERSION = 0x0002.toShort()
    }

    // Data class for message
    data class Message(
        val srcAddress: Byte,
        val tgtAddress: Byte,
        val msgType: Byte,
        val payloadLength: Short,
        val payload: ByteArray,
        val crc: Short) {

        // Method to convert message to byte array
        fun toByteArray(): ByteArray {
            val byteArray = ByteArray(payloadLength + NUM_OVERHEAD_BYTES)
            byteArray[HEADER_POS_0] = HEADER_0
            byteArray[HEADER_POS_1] = HEADER_1
            byteArray[HEADER_POS_2] = HEADER_2
            byteArray[SRC_ADDRESS_POS] = srcAddress
            byteArray[TGT_ADDRESS_POS] = tgtAddress
            byteArray[MSG_TYPE_POS] = msgType
            byteArray[PAYLOAD_LENGTH_MSB_POS] = (payloadLength.toInt() shr 8).toByte()
            byteArray[PAYLOAD_LENGTH_LSB_POS] = payloadLength.toByte()
            for (i in 0 until payloadLength) {
                byteArray[PAYLOAD_POS + i] = payload[i]
            }
            byteArray[byteArray.size - 2] = (crc.toInt() shr 8).toByte()
            byteArray[byteArray.size - 1] = crc.toByte()
            return byteArray
        }

        // Method to convert byte array to message
        fun fromByteArray(byteArray: ByteArray): Message {
            val srcAddress = byteArray[SRC_ADDRESS_POS]
            val tgtAddress = byteArray[TGT_ADDRESS_POS]
            val msgType = byteArray[MSG_TYPE_POS]
            val payloadLength = ((byteArray[PAYLOAD_LENGTH_MSB_POS].toInt() shl 8) or byteArray[PAYLOAD_LENGTH_LSB_POS].toInt()).toShort()
            val payload = ByteArray(payloadLength.toInt())
            for (i in 0 until payloadLength) {
                payload[i] = byteArray[PAYLOAD_POS + i]
            }
            val crc = ((byteArray[byteArray.size - 2].toInt() shl 8) or byteArray[byteArray.size - 1].toInt()).toShort()
            return Message(srcAddress, tgtAddress, msgType, payloadLength, payload, crc)
        }

        // Method to calculate CRC
        fun calculateCrc(): Short {
            val array = toByteArray()
            var crc = 0xFFFF.toShort()
            for (i in 0 until array.size - 2) {
                crc = (crc.toInt() xor array[i].toInt()).toShort()
                for (j in 0 until 8) {
                    if (crc.toInt() and 0x0001 != 0) {
                        crc = ((crc.toInt() shr 1) xor 0xA001).toShort()
                    } else {
                        crc = (crc.toInt() shr 1).toShort()
                    }
                }
            }
            return crc
        }
    }

    // Public address fields
    var myAddr: Byte = 0x00.toByte()
    var broadcastAddr: Byte = 0xFF.toByte()

    fun someLibraryMethod(): Boolean {
        return true
    }

    // Method to create a message, returns a Message object
    fun createMessage(
        tgtAddress: Byte,
        msgType: Byte,
        payload: ByteArray,
        isBroadcast: Boolean): Message{
        // Check the payload length and throw an exception if it is too long
        if (payload.size > MAX_PAYLOAD_LENGTH) {
            throw Exception("Payload length cannot exceed $MAX_PAYLOAD_LENGTH bytes")
        }
        val payloadLength = payload.size.toShort()
        val srcAddress = if (isBroadcast) broadcastAddr else myAddr
        val crc = Message(srcAddress, tgtAddress, msgType, payloadLength, payload, 0).calculateCrc()
        return Message(srcAddress, tgtAddress, msgType, payloadLength, payload, crc)
    }

    // Method to parse an incoming byte array, returns a Message object
    fun parseMessage(byteArray: ByteArray): Message? {
        return null
    }
}
