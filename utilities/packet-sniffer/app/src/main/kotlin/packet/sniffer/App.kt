/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package packet.sniffer
import serial.protocol.*
import com.fazecast.jSerialComm.*;

class App {
    val greeting: String
        get() {
            return "Hello World!"
        }
}

// Main function that accepts command line arguments
fun main(args: Array<String>) {
    // Verbose output disabled by default
    var verbose = false

    // Search for the port name argument from the command line
    var portName = ""
    for (i in 0 until args.size) {
        if (args[i] == "-p") {
            portName = args[i + 1]
        }
    }

    // Search for the baud rate argument from the command line
    var baudRate = 0
    for (i in 0 until args.size) {
        if (args[i] == "-b") {
            baudRate = args[i + 1].toInt()
        }
    }

    // For now override the port name and baud rate
    portName = "/dev/ttyACM0"
    baudRate = 115200

    // Attempt to open the port, handle errors
    var port : SerialPort? = null
    try {
        port = SerialPort.getCommPort(portName)
        port.baudRate = baudRate
        port.openPort()
    } catch (e: Exception) {
        println("Error opening port: " + e.message)
        return
    }

    // Main loop of the program, read data from the port and print any messages received
    var protocol = CommsProtocol()
    protocol.ignoreSrcAddr = true
    //protocol.logEnabled = true
    while(true) {
        // Read data from the port
        val numBytesAvailable = port.bytesAvailable()
        if (numBytesAvailable > 0) {
            val readBuffer = ByteArray(numBytesAvailable)
            val numBytesRead = port.readBytes(readBuffer, numBytesAvailable.toLong())
            if (verbose)
                println("Read $numBytesRead bytes from the port.")

            // Print the data
            if (verbose) { 
                for (i in 0 until numBytesRead) {
                    print(String.format("%02X ", readBuffer[i]))
                }
                println()
            }

            // Attempt to parse the data as a message
            val messages = protocol.parseMessage(readBuffer)
            for( msg in messages) {
                println("----------------------------------------")
                println("Message received:")
                println("Source address: ${msg.srcAddress}")
                println("Target address: ${msg.tgtAddress}")
                println("Message type: ${msg.msgType}")
                println("Payload length: ${msg.payloadLength}")
                if( msg.payloadLength > 0) {
                    println("Payload:")
                    for (i in 0 until msg.payloadLength) {
                        print(String.format("%02X ", msg.payload[i]))
                    }
                    println()
                }
                println("CRC: ${msg.crc}")
                println("----------------------------------------")
            }
        }
    }
}
